# On the (Surprising) Sufficiency of Linear Models for Dynamic Pricing with Demand Learning



> All models are wrong, but some are useful. -George E.P.Box



## Introduction & Model Description

Consider one monopoly offering a single product in the market. Then we assume the time is discrete and denote $t(t>0)$ as the different time period. At time t the seller can modify the price at time $t+1$. And at each time the demand would correspond to the current price based on the **real demand curve**. 

Then we respectively denote the price and demand at time $t$ as $p_t$ and $D_t$, and the real demand curve as $\lambda$.

We assume that the interval for $p_t$​ is $[p^{l}, p^{h}]$​, and $D_t = \lambda(p_t) + \varepsilon_t$​, where $\lambda(p_t)$​ is the deterministic function and $\varepsilon_t$​ is a random variable with zero-mean normal distribution. We assume that $\lambda(p_t)$​ has three types of function: **linear**,**exponential**,**logit**.

Because the deterministic function is fixed, at each time there is a price $p^*$​​ denoting the best price which can maximize the revenue function  $p_t * \lambda(p_t)$.

Our methods uses the data collected in the past periods, which contains the price and demand at each time before, to predict the most suitable price at time $t={i+1}$​​​​ , just based on single linear regression.

Our methods can be illustrated into the following steps:

1. Prediction

   Use the regression model to predict the best price $\hat{p}$, and set price at time $t=i$ as $\hat{p}$, and at time $t = i + 1$ as $\hat{p} + \delta$, where $\delta = t^{-\frac{1}{4}}$​ . Then you can get the information of the demand at time $t = i,i+1$.

2. Recalibration

   Since you've got the new data, you can use all the data before to create a new model using OLS, which can create a new model to map price to demand.

Then we have some metrics to measure the performance of the model:

- We can use the regret of any admissible policy which can be written as:

  ​                                                           $R(\pi,T) = p^{*}\cdot\lambda(p^{*})\cdot T  - Exp^{\pi}[\sum_{t=1}^{T}p_t\cdot D_t]$​



We can write a function to resemble the $\lambda$​ function:

``` python
def underlying(form,a,b,sigma):
    def linear(p):
        var =  random.normalvariate(0,sigma)
        demand = a - b*p + var
        return demand
    def exponential(p):
        var =  random.normalvariate(0,sigma)
        demand = math.exp(a - b*p) + var
        return demand
    def logit(p):
        var =  random.normalvariate(0,sigma)
        demand = math.exp(a - b*p)/(1+math.exp(a - b*p)) + var
        return demand
    if form == 'linear':
        return linear
    elif form == 'exponential':
        return exponential
    elif form == 'logit':
        return logit
```



## Simulation 

### 1. Theorem1(Consistency): pricing decisions generated by these policies converge

```Python
sigma = 0.5
index = 0
plt.figure(figsize = (18, 120))
for a in range(10,20):
    for b in range(1,3):
        index += 1
        title = "D = " + str(a) + ' - ' + str(b) + '*p'
        p_star = a/(2*b)
        func = underlying('linear',a,b,sigma)
        T = 0
        historical_price = []
        historical_demand = []
        T += 1
        p = 1
        d = func(p)
        historical_price.append(p)
        historical_demand.append(d)
        T += 1
        p = p + T**(-0.25)
        d = func(p)
        historical_price.append(p)
        historical_demand.append(d)
        for i in range(50):
            X = sm.add_constant(historical_price)
            model = sm.OLS(historical_demand,X)
            results = model.fit()
            T += 1
            p = -results.params[0]/(2*results.params[1])
            d = func(p)
            historical_price.append(p)
            historical_demand.append(d)
            T += 1
            p = p + T**(-0.25)
            d = func(p)
            historical_price.append(p)
            historical_demand.append(d)
        data = historical_price[::2]
        plt.subplot(20, 2, index)
        plt.plot(data)
        plt.plot([0,50],[p_star,p_star],color = 'r')
        plt.title(title)
        plt.xlabel('T')
        plt.ylabel('P')
plt.tight_layout()
```



![image-20211007140806902](C:\Users\TroyeCooper\AppData\Roaming\Typora\typora-user-images\image-20211007140806902.png)



###  Theorem2:  simple policy accumulate revenues close to optimal

## 

``` python
func = underlying('logit',4.1,1,0.5)
sum_alpha,sum_beta = [0 for i in range(50)],[0 for i in range(50)]
for _ in range(30):
    T = 0
    historical_price = []
    historical_demand = []
    alpha = []
    beta = []
    T += 1
    p = 1
    d = func(p)
    historical_price.append(p)
    historical_demand.append(d)
    T += 1
    p = p + T**(-0.25)
    d = func(p)
    historical_price.append(p)
    historical_demand.append(d)
    for i in range(50):
        X = sm.add_constant(historical_price)
        model = sm.OLS(historical_demand,X)
        results = model.fit()
        T += 1
        alpha.append(results.params[1])
        beta.append(results.params[0])
        p = -results.params[0]/(2*results.params[1])
        if p<= 0:
            p = 1
        d = func(p)
        historical_price.append(p)
        historical_demand.append(d)
        T += 1
        p = p + T**(-0.25)
        d = func(p)
        historical_price.append(p)
        historical_demand.append(d)
    for i in range(50):
        sum_alpha[i] = sum_alpha[i] +alpha[i]
        sum_beta[i] = sum_beta[i] +beta[i]
alpha,beta = [],[]
for i in sum_alpha:
    alpha.append(i/30)
for i in sum_beta:
    beta.append(i/30)
```

``` python
def r_logit(p):
    return np.exp(4.1 - p)/(1+np.exp(4.1 - p)) 
def l2(p):
    return beta[1] + alpha[1]*p
def l3(p):
    return beta[2] + alpha[2]*p
def l30(p):
    return beta[29] + alpha[29]*p
x = np.arange(0,10,0.1)
plt.figure(figsize=(6,12))
plt.plot(x,r_logit(x),color = 'indigo',label='underlying')
plt.plot(x,l2(x),label="iteration 2",color = 'red',linestyle = '--')
plt.plot(x,l3(x),color = 'limegreen',linestyle = '--',label="iteration 3")
plt.plot(x,l30(x),color = 'pink',linestyle = '--',label="iteration 30")
plt.xlabel("Price")
plt.ylabel("demand Functions")
plt.xlim((0, 10))
plt.ylim((0, 1.2))
plt.legend()
plt.show()
```

``` python
def pr_logit(p):
    return p*(np.exp(4.1 - p)/(1+np.exp(4.1 - p)))
def pl2(p):
    return p*(beta[1] + alpha[1]*p)
def pl3(p):
    return p*(beta[2] + alpha[2]*p)
def pl30(p):
    return p*(beta[29] + alpha[29]*p)
x = np.arange(0,10,0.1)
plt.figure(figsize=(6,12))
plt.plot(x,pr_logit(x),color = 'indigo',label='underlying')
plt.plot(x,pl2(x),label="iteration 2",color = 'red',linestyle = '--')
plt.plot(x,pl3(x),color = 'limegreen',linestyle = '--',label="iteration 3")
plt.plot(x,pl30(x),color = 'pink',linestyle = '--',label="iteration 30")
plt.xlabel("Price")
plt.ylabel("Revenue Functions")
plt.xlim((0, 10))
plt.ylim((0, 2.5))
plt.legend()
plt.show()
plt.savefig("th4.png")
```



第一次尝试：

<img src="C:\Users\TroyeCooper\AppData\Roaming\Typora\typora-user-images\image-20211012163428161.png" alt="image-20211012163428161" style="zoom: 67%;" />





<img src="C:\Users\TroyeCooper\AppData\Roaming\Typora\typora-user-images\image-20211012163506981.png" alt="image-20211012163506981" style="zoom:67%;" />



第二次尝试：

<img src="C:\Users\TroyeCooper\AppData\Roaming\Typora\typora-user-images\image-20211012163646017.png" alt="image-20211012163646017" style="zoom:67%;" />

<img src="C:\Users\TroyeCooper\AppData\Roaming\Typora\typora-user-images\image-20211012163710303.png" alt="image-20211012163710303" style="zoom:67%;" />



第三次尝试：

<img src="C:\Users\TroyeCooper\AppData\Roaming\Typora\typora-user-images\image-20211012163825298.png" alt="image-20211012163825298" style="zoom:67%;" />

<img src="C:\Users\TroyeCooper\AppData\Roaming\Typora\typora-user-images\image-20211012163844380.png" alt="image-20211012163844380" style="zoom:67%;" />
